### 문제 요약
- 길이가 N인 이진 문자열을 만들되, 사용 가능한 타일은 "1" 또는 "00" 뿐이다.
- 만들 수 있는 서로 다른 문자열의 개수를 구해야 한다.
- 결과가 매우 커질 수 있으므로 답을 15746을 나눈 나머지를 출력한다.
- 입력 범위 : 1 <= N <= 1,000,000

### 접근 & 오류
- 가능한 모든 문자열을 생성해서 세어보려고 했다. -> 경우의 수가 기하급수적으로 커지므로 시간/메모리 초과
- 배열로 DP 구현하여 작은 수부터 채워나가야 하나? -> int 범위 넘어서 오버플로우 발생

### 해결 방법
- 마지막에 오는 것이 "1" -> 앞은 길이 n-1 (dp[n-1])
- 마지막에 오는 것이 "00" -> 앞은 길이 n-2 (dp[n-2])
- 따라서 dp[n] = dp[n-1] + dp[n-2]
- 배열 전체를 저장할 필요는 없고, 직전 두 값만 있으면 된다. 따라서 두 값의 변수만 관리
- 피보나치 점화식 구조임을 인식하고 배열 대신 두 변수만 사용하여 매번 mod 연산 적용을 함으로써 해결