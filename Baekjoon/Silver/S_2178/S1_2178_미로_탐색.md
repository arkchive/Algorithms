### 문제 요약
- 입력
    - 첫 줄: N M(2 <= N, M <= 100)
    - 다음 N줄: 길이 M인 문자열(문자 0 또는 1)
        1: 이동 가능한 칸, 0: 벽
- 시작/도착
    - 시작: 좌상단(0, 0)
    - 도착: 우하단(N-1. M-1)
- 이동 규칙
    - 상/하/좌/우 네 방향으로만 한 칸씩 이동 가능(대각선 x)
    - 모든 간선 가중치는 동일(=1칸 이동)
- 출력
    - 시작에서 도착까지의 최단 이동 칸 수(방문한 칸의 개수)
    - 즉, 경로 길이를 "간선 수"가 아닌 "지나간 칸 수"로 센 값 -> 시작 칸도 1로 포함

### 접근 & 오류
DP로 풀려고 함. 직관적으로 dp[i][j] = min(dp[이웃]) + 1 같은 식으로 최소값을 누적하려고 시도
하지만 이 문제는
    - 상/하/좌/우로 이동 가능 -> 순환(cycle) 발생 가능
    - 오른쪽/아래만 처럼 단조로운 이동이 아님 -> 위상 순서 불가능
    - 결국 한 번에 명확한 이전 상태 집합을 정의하기 어렵다. 
이 문제는 최단거리지만 dp가 성립하려면 사이클이 없거나 방향이 제한된 격자여야한다. 4방향 이동 + 사이클에서는 dp로 최단거리를 안전하게 보장하기 어렵고, 동일 가중치 최단 거리 = BFS가 맞는 접근이다. 
- 구현 핵심
    - 큐에 현재 칸을 넣고, 네 방향 이웃을 조건에 맞으면 넣는다.
    - 방문 체크는 큐에 넣는 순간에 한다. (중복 삽입 방지)
    - 도착 칸을 큐에서 꺼낸 순간 즉시 반환(조기 종료)

### 해결 방법
1. maze 덮어쓰기 + visited 방식
    - maze를 지도에서 거리 배열로 덮어쓴다.
    - 시작 점은 반드시 maze[x][y] = 1로 거리 기준을 명시한다.
    - 방문 체크는 visited[nx][ny] = true를 enqueue 직전에
    - 도착하면 return maze[cx][cy];
2. dist[][]분리(visited 없이 dist로 방문 관리) 방식
    - maze는 지도로만 사용
    - dist는 최단 거리 저장
    - 방문 체크는 dist[nx][ny] != 0으로 대체
    - 도착하면 return dist[cx][cy]

1. 초기세팅
    - 시작점(x, y)를 큐에 넣고(offer), visited[x][y] = true.
    - 거리 시작점 명시(maze[x][y] = 1 / dist[x][y] = 1)
2. 반복 탐색 (BFS 루프)
    - 큐에서 현재 칸 cur = poll() -> (cx, cy) 꺼내기.
    - 만약 현재 칸이 도착점(N-1, M-1)이면, 여기 저장된 값(maze[cx][cy])이 최단 이동 횟수이므로 즉시 반환.
3. 네 방향 이웃 검사
    - dir = 0..3에 대해 (nx, ny) = (cx + dx[dir], cy + dy[dir]).
    - 배열 범위를 벗어나면 continue.
    - 벽(0)이 있거나 이미 방문했다면 continue.
    - 이동 가능하면, maze[nx][ny] = maze[cx][cy] + 1로 거리 갱신
    - visited[nx][ny] = true로 방문 처리하고 큐에 넣기(offer).
4. 큐에 빌 때까지 반복
    - BFS는 가까운 칸부터 탐색하므로, 처음 도착하는 순간의 거리가 최단 거리이다. 
5. 끝
    - 그래도 혹시를 대비해, 루프가 끝났는데도 도달 못했으면 0 반환.